---
title: "warmXtrophic Project: Greenup Analyses"
author: "Kara Dobson, Phoebe Zarnetske"
date: "`r format(Sys.time(), '%B %d, %Y')`"
output: pdf_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(knitr)
library(kableExtra)
opts_chunk$set(tidy.opts=list(width.cutoff=80),tidy=TRUE)
```

# Script Details:
```{r, message = F}
script_tbl <- data.frame(
  Item = c("OVERVIEW", "COLLABORATORS", "REQUIRES", "DATA INPUT", "DATA OUTPUT", "NOTES"),
  Details = c("This script explores and analyses the greenup data from the KBS and UMBS stations. Greenup was recorded as percent cover of each species in each plot every 3 days in the beginning of the field season. Percent cover continued to be measured until the end of the field season. For calculating greenup dates, we use the date at which 50% of a species maximum percent cover was reached for each plot, to account for variation in litter depth affecting the early season's first greenup date.",
              "Moriah Young, Mark Hammond, Pat Bills",
              "Prior to running this script, make sure plant_comp_clean_L0.R is run and up to date. That script creates the final_greenup_L1.csv in the L1 folder in the Google drive, which contains the clean greenup data",
              "Data imported as csv files from shared Google drive 'SpaCE_Lab_warmXtrophic' plant comp folder",
              "... a brief description of the data output from through the script, including what format it’s in",
              "Each row in 'greenup' is the date at which spp_half_cover_date was recorded, per species. The 'green_kbs' and 'green_umbs' dataframes contain data for greenup at each site."
  )
)

kbl(script_tbl) %>%
  kable_paper(full_width = F) %>%
  column_spec(1, bold = T, border_right = T) %>%
  column_spec(2, width = "30em", background = "lightblue")

metadata_tbl <- data.frame(
  Variable = c("spp_half_cover_date", "plot_half_cover_date", "state"),
  Definition = c("date at which 50% of a species max cover was reached (per species, per plot, per year)", 
    "the date at which 50% of a plot's max cover was reached (per plot, per year)",
    "describes each treatment: warmed or ambient"
  )
)

kbl(metadata_tbl) %>%
  kable_paper(full_width = F) %>%
  column_spec(1, bold = T, border_right = T) %>%
  column_spec(2, width = "30em", background = "lightyellow")

```


```{r, message = FALSE, warning = FALSE}
# Clear all existing data
rm(list=ls())

#Load packages
library(tidyverse)
library(ggplot2)
library(lme4)
library(olsrr)
library(predictmeans)
library(car)
library(fitdistrplus)
library(ggpubr)
library(rstatix)
library(vegan)
library(interactions)
library(sjPlot)
library(effects)
library(glmmTMB)
#install.packages('TMB',type='source')

# Get data
Sys.getenv("L1DIR")
L1_dir<-Sys.getenv("L1DIR")
list.files(L1_dir)
greenup <- read.csv(file.path(L1_dir, "greenup/final_greenup_species_L1.csv"))
greenupp <- read.csv(file.path(L1_dir, "greenup/final_greenup_plot_L1.csv"))

# Set ggplot2 plots to bw: see here for more options: http://www.sthda.com/english/wiki/ggplot2-themes-and-background-colors-the-3-elements
theme_set(theme_bw(base_size = 14))
# check variable types
str(greenup)

# Order warm and ambient so that warm shows up first in plotting (and is default is red = warm; blue = ambient). First make it a factor.
greenup$state<-as.factor(greenup$state)
levels(greenup$state)
greenup$state <- factor(greenup$state, levels(greenup$state)[c(2,1)])
levels(greenup$state)

greenupp$state<-as.factor(greenupp$state)
levels(greenupp$state)
greenupp$state <- factor(greenupp$state, levels(greenupp$state)[c(2,1)])
levels(greenupp$state)

# adding sequential year variable starting at 1: this is because 2016... are large numbers compare with other values in the dataset. We can always label axes with these real years.
greenup$year1<-greenup$year
greenup$year[greenup$year == 2016] <- 1
greenup$year[greenup$year == 2017] <- 2
greenup$year[greenup$year == 2018] <- 3
greenup$year[greenup$year == 2019] <- 4
greenup$year[greenup$year == 2020] <- 5

greenupp$year1<-greenupp$year
greenupp$year[greenupp$year == 2016] <- 1
greenupp$year[greenupp$year == 2017] <- 2
greenupp$year[greenupp$year == 2018] <- 3
greenupp$year[greenupp$year == 2019] <- 4
greenupp$year[greenupp$year == 2020] <- 5

# create dataframes for kbs and umbs - remember that these contain species within plots
green_kbs <- subset(greenup, site == "kbs")
green_umbs <- subset(greenup, site == "umbs")

green_kbsp <- subset(greenupp, site == "kbs")
green_umbsp <- subset(greenupp, site == "umbs")
```

# Data Exploration: are there differences between warmed vs. ambient plots when we account for species?
# *Starting with KBS*

# First, checking for normality in raw data. This is a little weird to do because each row in the dataframe is a species-plot combo, so you're missing the influence of species below. Instead, re-run this on plot-level half cover date (re-compute this in plant_comp_clean_L0.R to get that variable first). It's also not going to tell you about normality once you fit a model to these data - that's when you really need to investigate the residuals.
# *Note that since this change, some of the code below breaks because the variable name changed. Also, there seem to be some errors popping up with qqPlot, suggesting that something else changed when this new variable was created. Check* 
```{r}
# remove species, origin, duration,growth habit,spp_half_cover_date - again, this should be done in other script preceding this one
green_kbsp<-subset(green_kbsp,select=c("plot_half_cover_date","min_green_date","plot","year","state","insecticide","site","year1"))
head(green_kbsp)

hist(green_kbsp$plot_half_cover_date)
qqnorm(green_kbsp$plot_half_cover_date)
shapiro.test(green_kbsp$plot_half_cover_date)

# histograms for each treatment separately 
hist(green_kbsp$plot_half_cover_date[green_kbsp$state == "ambient"])
hist(green_kbsp$plot_half_cover_date[green_kbsp$state == "warmed"])

# histograms for each year - look at them together:
p1 <- ggplot(data = green_kbsp, aes(x = plot_half_cover_date, fill=state)) + geom_histogram(alpha=0.5, binwidth=10)
p1 + facet_wrap(~year1) + labs(title="Plot-level half cover date")

p1 <- ggplot(data = green_kbs, aes(x = spp_half_cover_date, fill=state)) + geom_histogram(alpha=0.5, binwidth=10)
p1 + facet_wrap(~year1) + labs(title="Species-level half cover date")

# this will just show sampling date artifact
p2 <- ggplot(data = green_kbsp, aes(x = min_green_date, fill=state)) + geom_histogram(alpha=0.5, binwidth=10)
p2 + facet_wrap(~year1)

# Density plot
p3 <- ggplot(data = green_kbsp, aes(x = plot_half_cover_date, fill=state)) + geom_density(alpha=0.5)
p3 + facet_wrap(~year1) + labs(title="Plot-level half cover date")

p3 <- ggplot(data = green_kbs, aes(x = spp_half_cover_date, fill=state)) + geom_density(alpha=0.5)
p3 + facet_wrap(~year1) + labs(title="Species-level half cover date")

# this will just show sampling date artifact
p4 <- ggplot(data = green_kbsp, aes(x = min_green_date, fill=state)) + geom_density(alpha=0.5)
p4 + facet_wrap(~year1)

# Or try with tidyverse format
green_kbsp.t<-as_tibble(green_kbsp)
green_kbsp.t %>%
    gather(state, plot_half_cover_date, year1) %>%
    ggplot(aes(plot_half_cover_date, fill = state)) + geom_histogram() + facet_wrap(~year1)

# looks like the 225 spike is from 2018 and 2020 - what's going on here is that you are treating all species-plot records as independent observations, so the influence of species differences is likely coming through here.
kbs_2018 <- subset(green_kbs, year == 4) # many records on 235
kbs_2020 <- subset(green_kbs, year == 6) # records from 227 & 228
```

\pagebreak

# Leverage plots and detecting Outliers. https://www.statmethods.net/stats/rdiagnostics.html
# These illustrate whether certain data points have more leverage (more influence), and thus could be outliers. It's a way of detecting outliers. Leverage plots can help identify whether a point has high or low influence, based on its leverage and residual and determining model fit with and without the point in question. Ultimately you decide whether the points are outliers or not, based on the knowledge of the system and how much it changes the model when included vs. excluded from the data used to fit the model. Here is a good overview of the combination of leverage and residual: scroll down to sections beginning at "13.3 Unusual Observations": https://daviddalpiaz.github.io/appliedstats/model-diagnostics.html
```{r}
# checking fit for date as a function of state and species - bringing in species here makes it obvious that that is explaining some of the variation compared with the state-only model you had previously.

# State-only model (not really correct bc species differ)
fit<- lm(spp_half_cover_date~state, data = green_kbs)
outlierTest(fit)
# record 551 is the largest outlier

# State-only model - not really correct bc species should be included
fit<- lm(spp_half_cover_date~state, data = green_kbs)
outlierTest(fit) 
qqPlot(fit, main="QQ Plot") 
hist(fit$residuals)
leveragePlots(fit)

# State and species model 
fit1 <- lm(spp_half_cover_date~state + species, data = green_kbs)
outlierTest(fit1) # no outliers
hist(fit1$residuals)
qqPlot(fit1, main="QQ Plot") 
leveragePlots(fit1)

fit1a <- lm(min_green_date~state + species, data = green_kbs)
outlierTest(fit1a) # no outliers
hist(fit1a$residuals)
qqPlot(fit1a, main="QQ Plot") 
leveragePlots(fit1a)

# checking fit for date as a function of state and year
fit2 <- lm(spp_half_cover_date~state+species+year, data = green_kbs)
hist(fit2$residuals)
outlierTest(fit2) # no outliers
qqPlot(fit2, main="QQ Plot") 
leveragePlots(fit2)
```

\pagebreak

# Normal distribution after accounting for species - we will be using species as a random effect to account for their variation. Set up some linear mixed effects models to evaluate. From Ben Bolker: "The traditional view of random effects is as a way to do correct statistical tests when some observations are correlated. ... Random effects are especially useful when we have (1) lots of levels (e.g., many species or blocks), (2) relatively little data on each level (although we need multiple samples from most of the levels), and (3) uneven sampling across levels. People sometimes say that random effects are “factors that you aren’t interested in.” This is not always true. While it is often the case in ecological experiments (where variation among sites is usually just a nuisance), it is sometimes of great interest." In our case, variation among plots is a nuisance, and not something we're interested in. For some questions, variation among species is also a nuisance for us. It's possible that variation among years is a nuisance if we only care about warm vs. ambient, but I think time is an interesting variable to consider with this study. 

# We should also think about how we're treating year. Some of the models have a state * year interaction as a fixed effect, which means that the warming or ambient treatment could affect the half_cover_date differently over time (there would be a different slope for each state in the relationship between half_cover_date (y) and year (x)). If we just had state + year, the states would have the same slope, indicating that they have no interaction in their effect on half_cover_date (but they could still have different intercepts).

```{r}
# Interaction plot (ignore for now the repeated measures with species); see: https://cran.r-project.org/web/packages/interactions/vignettes/interactions.html and: https://interactions.jacob-long.com/

fit3 <- lm(plot_half_cover_date ~ state + year, data = green_kbsp)
interact_plot(fit3, pred = year, modx = state)
fit4 <- lm(plot_half_cover_date ~ state * year, data = green_kbsp)
interact_plot(fit4, pred = year, modx = state)

fit5 <- lm(spp_half_cover_date ~ state + year + species, data = green_kbs)
interact_plot(fit5, pred = year, modx = state)
fit6 <- lm(spp_half_cover_date ~ state * year + species, data = green_kbs)
interact_plot(fit6, pred = year, modx = state, mod2 = species)

fit7 <- lm(min_green_date ~ state + year + species, data = green_kbs)
interact_plot(fit7, pred = year, modx = state)
fit8 <- lm(min_green_date ~ state * year + species, data = green_kbs)
interact_plot(fit8, pred = year, modx = state, mod2 = species)
```

Mixed Effects Models:
```{r}
# Start by replicating (almost) what we did in the Oecologia 2018 paper. The only difference here is that we have multiple years, so we are also including year as a fixed effect and as an interactive term. Our goal here is to find a model that is the best fit to the data. We also want to find a model that is the most parsimonious (one that has the fewest parameters).

# Do we need to include plot as a random effect with the KBS models?   
mod1 <- lmer(spp_half_cover_date ~ state*year + insecticide*year + (1|species) + (1|plot), green_kbs, REML=FALSE)
mod2 <- lmer(spp_half_cover_date ~ state*year + insecticide*year + (1|species), green_kbs, REML=FALSE)
# Run analysis of variance on each model (see this for more explanation on how anova on a linear mixed effects model is similar to an anove on a regular linear model: https://m-clark.github.io/docs/mixedModels/anovamixed.html)
anova(mod1)
anova(mod2)

# Run an ANOVA to test if 2 models to test whether the more complex model is significantly better at capturing the data than the simpler model. If the resulting p-value is sufficiently low (usually less than 0.05), we conclude that the more complex model is significantly better than the simpler model, and thus favor the more complex model. If the p-value is not sufficiently low (usually greater than 0.05), we should favor the simpler model. https://bookdown.org/ndphillips/YaRrr/comparing-regression-models-with-anova.html
anova(mod2, mod1) # They are different so plot as a random effect should stay in the model (we go with mod1)
summary(mod1) 
summary(mod2)

# Next, plot the model. There are multiple variables but here's one way to do it based on this package sjPlot:
# https://strengejacke.github.io/sjPlot/articles/plot_model_estimates.html
# Annoyingly, this package somehow overwrites the factor order in its plotting so we will have to modify the code to get warmed = red. I haven't figured this out yet. It does seem to work on some of the plots. hmm.
?plot_model
# Plot the fixed effects estimates for different models
# these are the fixed effects estimates from summary(mod5)
plot_model(mod1, sort.est = TRUE)
# these are the fixed predicted values:
plot_model(mod1, type = "pred", terms = c("year", "state", "insecticide"))
# these are the random effects estimates
plot_model(mod1, type = "re", terms = c("species", "plot"))

# Do we need to include insecticide? 
mod3 <- lmer(spp_half_cover_date ~ state*year + (1|species), green_kbs, REML=FALSE)
anova(mod1, mod3)
# Looks like yes P<0.05, insecticide improves model fit so we will continue to include it and stick with mod1

# Does year need to be interactive with insecticide?
mod4 <- lmer(spp_half_cover_date ~ state*year + insecticide + (1|species) + (1|plot), green_kbs, REML=FALSE)
anova(mod1, mod4)
# No, P>0.05 so insecticide*year doesn't strongly improve model fit so we will shift to mod4
anova(mod3, mod4)
# Yes, P<0.05 so insecticide still improves model fit so we will stay with mod4

# Does year need to be interactive with state?
mod5 <- lmer(spp_half_cover_date ~ state + year + insecticide + (1|species) + (1|plot), green_kbs, REML=FALSE)
anova(mod4, mod5)
# No, P>0.05 so state*year doesn't improve model fit so we could drop it and go with mod5, but note that the AIC values are super close. mod4 makes sense, with increased divergence between warmed and ambient.
summary(mod4)
anova(mod4)

# these are the fixed effects estimates from summary(mod5)
plot_model(mod4, sort.est = TRUE)
# these are the fixed predicted values:
plot_model(mod4, type = "pred", terms = c("year", "state", "insecticide"))
# these are the random effects estimates
plot_model(mod4, type = "re", terms = c("species", "plot"))

# If we wanted to include plots nested within year it would look like this:
mod7 <- lmer(spp_half_cover_date ~ state*year + insecticide + (1|species) + (1+year|plot), green_kbs, REML=FALSE)
anova(mod4, mod7)
anova(mod7)
# Yup, seems to matter but it is making this more complex, though not overly so because it's on the random effects structure only.
plot_model(mod7, sort.est = TRUE)
# these are the fixed predicted values:
plot_model(mod7, type = "pred", terms = c("year", "state", "insecticide"))
# these are the random effects estimates
plot_model(mod7, type = "re", terms = c("species", "plot"))

# mod4 (and mod7) are pretty complex in terms of interpretation (they actually don't have many parameters though). We could consider an alternative model that's simpler to understand and also one that provides more insight about the species. That would be something like this:
# We're going to use lmerTest for this example so you can see how to run through post-hoc tests.
library(lmerTest)
mod8 <- lmer(spp_half_cover_date ~ state + species + (1+year|plot), green_kbs, REML=FALSE)
anova(mod7, mod8) # model 8 is a better fit to data
summary(mod8)
anova(mod8) # investigates whether at least one of the levels within each factor is significantly different. 
# Yes, at least one of the species is different (they do not all have the same half cover dates). 

# Take a look at the estimates for each fixed effect. These are the estimates from summary(mod8). You'll see that species vary a lot - and many of them are different from zero (meaning their half cover date is significantly different from zero).
plot_model(mod8, sort.est = TRUE)
# if you want to standardize the estimates:
plot_model(mod8, sort.est = TRUE, type="std") 
# these are the fixed predicted values: - note this is a new plot
plot_model(mod8, type = "pred", terms = c("species", "state"))
# these are the random effects estimates
plot_model(mod8, type = "re")

# You could now run some post hoc tests on these (see: https://stats.stackexchange.com/questions/169543/output-of-fixed-effects-summary-in-lmertest-in-r-and-post-hoc-tests)

# Here are some other options for plotting these plots above: 
# https://stackoverflow.com/questions/31075407/plot-mixed-effects-model-in-ggplot

# Here's another approach:
# https://stats.stackexchange.com/questions/98958/plots-to-illustrate-results-of-linear-mixed-effect-model
# Not quite working yet:
newdat <- expand.grid(state=unique(green_kbs$state),
                  year=c(min(green_kbs$year),
                            max(green_kbs$year)),
                  insecticide=unique(green_kbs$insecticide))
p <- ggplot(green_kbs, aes(x=year, y=spp_half_cover_date, colour=state, shape=insecticide)) +
  geom_point(size=3) +
  geom_line(aes(y=predict(mod5), group=species, size="species")) +
  geom_line(data=newdat, aes(y=predict(mod5, level=0, newdata=newdat), size="Population")) +
  scale_size_manual(name="Predictions", values=c("species"=0.5, "Population"=3)) +
  #facet_wrap(~insecticide) +
  theme_bw(base_size=22) 
print(p)

```

```{r}

# New version of our model incorporating interaction term and species within year so that there is a separate intercept and slope for each species. The issue here is that there are some species that are not found each year. Easiest to remove those from another version of this dataframe before running below. Otherwise, it's not a balanced design.
mod4 <- lmer(spp_half_cover_date ~ state * year + (1+year|species), green_kbs)

# So another version of this model would include the interaction but not include the nesting (and thus would assume that species aren't observed ea yr)
mod5 <- lmer(spp_half_cover_date ~ state * year + (1|species), green_kbs)
summary(mod5) 
```

# *ORIGINAL CODE BELOW; not edited by Phoebe* ##

# Seeing what other distribution could fit
```{r}
descdist(green_kbs$spp_half_cover_date, discrete = FALSE)
```
# While uniform looks the closest, I'll try poisson
```{r, fig.align='center'}
fit <- lm(spp_half_cover_date~state, data = green_kbs)
residual <- fit$residuals
hist(residual, main="Raw residuals")  
pois <- glm(spp_half_cover_date~state, data = green_kbs, family="poisson")
hist(pois$residuals, main="Poisson glm residuals")
```

\pagebreak

# Below I try a few different generalized linear models with poisson distribution:  

## An interaction between state and year, plus insecticide as a fixed effect and species and plot as random effects
```{r}
moda <- glmer(spp_half_cover_date ~ state*year + insecticide + (1|species) + (1|plot),
              data=green_kbs, family = poisson)
summary(moda)
```

\pagebreak

## No interaction between state and year, but with state and insecticide as fixed effects and species and plot as random effects
```{r}
modb <- glmer(spp_half_cover_date ~ state + year + insecticide + (1|species) + (1|plot),
              data=green_kbs, family = poisson)
summary(modb)
```

\pagebreak

## State and insecticide as fixed effects & year, species and plot as random effects
```{r}
modc <- glmer(spp_half_cover_date ~ state + insecticide + (1|year) + (1|species) + (1|plot),
              data=green_kbs, family = poisson)
summary(modc)
```

\pagebreak

# Because no distributions seems to match well, I'll try a Friedman's test
```{r}
#friedman_kbs <- green_kbs %>% 
#  friedman_test(spp_half_cover_date ~ state)
```
## Error: Must extract column with a single valid subscript. x Subscript `var` can't be `NA`
## Can't figure out what this means  

## If I include the blocks portion of the formula (from the documentation) I get this error
```{r}
#friedman_kbs <- green_kbs %>% 
#  friedman_test(spp_half_cover_date ~ state | plot)
```
## Error in friedman.test.default(c(141L, 202L, 122L, 101L, 127L, 120L, 197L,  :  not an unreplicated complete block design

# Permanova?
```{r, cache = T}
per1 <- adonis2(green_kbs$spp_half_cover_date ~ state*year + insecticide, data = green_kbs)
per1
per2 <- adonis(formula = green_kbs$spp_half_cover_date ~ state*year + insecticide, strata = green_kbs$plot, data = green_kbs)
per2
```
# With per2, when controlling for "plot", there is a difference btwn treatments

\pagebreak

# *UMBS*

# Checking for normality

```{r}
hist(green_umbs$spp_half_cover_date)
qqnorm(green_umbs$spp_half_cover_date)
shapiro.test(green_umbs$spp_half_cover_date)
hist(green_umbs$spp_half_cover_date[green_kbs$state == "ambient"])
hist(green_umbs$spp_half_cover_date[green_kbs$state == "warmed"])
```

## These look pretty good

\pagebreak

# Trying log transformation
```{r}
green_umbs$date_log <- log(green_umbs$spp_half_cover_date)
hist(green_umbs$date_log)
shapiro.test(green_umbs$date_log)
```
## I think this looks good but shapiro-wilk is lower than 0.05

\pagebreak

# Trying inverse tranformation
```{r}
green_umbs$date_inv <- 1/(green_umbs$spp_half_cover_date)
hist(green_umbs$date_inv)
shapiro.test(green_umbs$date_inv)
```
## This also looks good but is also still low for shapiro-wilk
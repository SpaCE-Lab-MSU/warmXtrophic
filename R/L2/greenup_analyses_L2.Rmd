---
title: "warmXtrophic Project: Greenup Analyses"
author: "Kara Dobson, Phoebe Zarnetske"
date: "`r format(Sys.time(), '%B %d, %Y')`"
output: pdf_document
editor_options: 
  chunk_output_type: console
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(knitr)
library(kableExtra)
opts_chunk$set(tidy.opts=list(width.cutoff=60),tidy=TRUE)
```

# Script Details:
```{r, message = F, eval=FALSE}

# this portion of the script won't knit, so its set to eval=F

script_tbl <- data.frame(
  Item = c("OVERVIEW", "COLLABORATORS", "REQUIRES", "DATA INPUT", "DATA OUTPUT", "NOTES"),
  Details = c("This script explores and analyses the greenup data from the KBS and UMBS stations. Greenup was recorded as percent cover of each species in each plot every 3 days in the beginning of the field season. Percent cover continued to be measured until the end of the field season. For calculating greenup dates, we use the date at which 50% of a species maximum percent cover was reached for each plot, to account for variation in litter depth affecting the early season's first greenup date.",
              "Moriah Young, Mark Hammond, Pat Bills",
              "Prior to running this script, make sure plant_comp_clean_L0.R is run and up to date. That script creates the final_greenup_L1.csv in the L1 folder in the Google drive, which contains the clean greenup data",
              "Data imported as csv files from shared Google drive 'SpaCE_Lab_warmXtrophic' plant comp folder",
              "... a brief description of the data output from through the script, including what format it’s in",
              "Each row in 'greenup' is the date at which spp_half_cover_date was recorded, per species. The 'green_kbs' and 'green_umbs' dataframes contain data for greenup at each site."
  )
)

kbl(script_tbl) %>%
  kable_paper(full_width = F) %>%
  column_spec(1, bold = T, border_right = T) %>%
  column_spec(2, width = "30em", background = "lightblue")

metadata_tbl <- data.frame(
  Variable = c("spp_half_cover_date", "plot_half_cover_date", "state"),
  Definition = c("date at which 50% of a species max cover was reached (per species, per plot, per year)", 
    "the date at which 50% of a plot's max cover was reached (per plot, per year)",
    "describes each treatment: warmed or ambient"
  )
)

kbl(metadata_tbl) %>%
  kable_paper(full_width = F) %>%
  column_spec(1, bold = T, border_right = T) %>%
  column_spec(2, width = "30em", background = "lightyellow")

```


```{r, message = FALSE, warning = FALSE}
# Clear all existing data
rm(list=ls())

#Load packages
library(tidyverse)
library(ggplot2)
library(lmerTest)
library(olsrr)
library(predictmeans)
library(car)
library(fitdistrplus)
library(ggpubr)
library(rstatix)
library(vegan)
library(interactions)
library(sjPlot)
library(effects)
library(glmmTMB)
library(bbmle)
library(emmeans)
library(gtsummary)
library(knitr)
#install.packages('TMB',type='source')

# Set ggplot2 plots to bw: see here for more options: http://www.sthda.com/english/wiki/ggplot2-themes-and-background-colors-the-3-elements
theme_set(theme_bw(base_size = 14))

# Get data
L1_dir<-Sys.getenv("L1DIR")
L2_dir<-Sys.getenv("L2DIR")
greenup <- read.csv(file.path(L2_dir, "greenup/final_greenup_species_L2.csv")) # spp level greenup dates
greenup <- greenup %>% dplyr::select(-X) # get rid of "X" column that shows up (could fix this in cleaning script)

greenupp <- read.csv(file.path(L2_dir, "greenup/final_greenup_plot_L2.csv")) # plot level greenup dates
greenupp <- greenupp %>% dplyr::select(-X) # get rid of "X" column that shows up

# V2 below is plot level, but is the median half cover date for all species per plot
# calculated in phenology_dates_L2
greenupp2 <- read.csv(file.path(L2_dir,"greenup/final_greenup_plot_V2_L2.csv")) # V2 plot level greenup dates
greenupp2 <- greenupp2 %>% dplyr::select(-X) # get rid of "X" column that shows up

# check variable types
str(greenup)
str(greenupp)
str(greenupp2)

# Order warm and ambient so that warm shows up first in plotting
greenup$state<-as.factor(greenup$state)
levels(greenup$state)
greenup$state <- factor(greenup$state, levels(greenup$state)[c(2,1)])
levels(greenup$state)

greenupp$state<-as.factor(greenupp$state)
levels(greenupp$state)
greenupp$state <- factor(greenupp$state, levels(greenupp$state)[c(2,1)])
levels(greenupp$state)

# adding sequential year variable starting at 1: this is because 2016... are large numbers compare with other values in the dataset. We can always label axes with these real years.
greenup$year_factor[greenup$year == 2016] <- 1
greenup$year_factor[greenup$year == 2017] <- 2
greenup$year_factor[greenup$year == 2018] <- 3
greenup$year_factor[greenup$year == 2019] <- 4
greenup$year_factor[greenup$year == 2020] <- 5
greenup$year_factor[greenup$year == 2021] <- 6
#greenup$year_factor <- as.factor(greenup$year_factor) # having year as numerical was messing with some analyses below (namely emmeans post-hoc analyses), so converted it to a factor

greenupp$year_factor[greenupp$year == 2016] <- 1
greenupp$year_factor[greenupp$year == 2017] <- 2
greenupp$year_factor[greenupp$year == 2018] <- 3
greenupp$year_factor[greenupp$year == 2019] <- 4
greenupp$year_factor[greenupp$year == 2020] <- 5
greenupp$year_factor[greenupp$year == 2021] <- 6
#greenupp$year_factor <- as.factor(greenupp$year_factor)

greenupp2$year_factor[greenupp2$year == 2016] <- 1
greenupp2$year_factor[greenupp2$year == 2017] <- 2
greenupp2$year_factor[greenupp2$year == 2018] <- 3
greenupp2$year_factor[greenupp2$year == 2019] <- 4
greenupp2$year_factor[greenupp2$year == 2020] <- 5
greenupp2$year_factor[greenupp2$year == 2021] <- 6
#greenupp$year_factor <- as.factor(greenupp$year_factor)

# create dataframes for kbs and umbs - remember that these contain species within plots
green_kbs <- subset(greenup, site == "kbs")
green_umbs <- subset(greenup, site == "umbs")

green_kbsp <- subset(greenupp, site == "kbs")
green_umbsp <- subset(greenupp, site == "umbs")

green_kbsp2 <- subset(greenupp2, site == "kbs")
green_umbsp2 <- subset(greenupp2, site == "umbs")
```

# Data Exploration:

# First, checking for normality in raw data. It's not going to tell you about normality once you fit a model to these data - that's when you really need to investigate the residuals.
```{r}
# species level
hist(green_kbs$spp_half_cover_date)
hist(green_umbs$spp_half_cover_date)

# plot level
hist(green_kbsp$plot_half_cover_date)
qqnorm(green_kbsp$plot_half_cover_date)
shapiro.test(green_kbsp$plot_half_cover_date)

hist(green_umbsp$plot_half_cover_date)
qqnorm(green_umbsp$plot_half_cover_date)
shapiro.test(green_umbsp$plot_half_cover_date)

hist(green_kbsp2$med_half_cover_date)
qqnorm(green_kbsp2$med_half_cover_date)
shapiro.test(green_kbsp2$med_half_cover_date)

hist(green_umbsp2$med_half_cover_date)
qqnorm(green_umbsp2$med_half_cover_date)
shapiro.test(green_umbsp2$med_half_cover_date)


# histograms for each treatment separately - plot level
hist(green_kbsp$plot_half_cover_date[green_kbsp$state == "ambient"])
hist(green_kbsp$plot_half_cover_date[green_kbsp$state == "warmed"])

# histograms for each year - look at them together:
p1 <- ggplot(data = green_kbsp, aes(x = plot_half_cover_date, fill=state)) + geom_histogram(alpha=0.5, binwidth=10)
p1 + facet_wrap(~year_factor) + labs(title="Plot-level half cover date")

p1.2 <- ggplot(data = green_kbs, aes(x = spp_half_cover_date, fill=state)) + geom_histogram(alpha=0.5, binwidth=10)
p1.2 + facet_wrap(~year_factor) + labs(title="Species-level half cover date")

p1u <- ggplot(data = green_umbsp, aes(x = plot_half_cover_date, fill=state)) + geom_histogram(alpha=0.5, binwidth=10)
p1u + facet_wrap(~year_factor) + labs(title="Plot-level half cover date")

p1.2u <- ggplot(data = green_umbs, aes(x = spp_half_cover_date, fill=state)) + geom_histogram(alpha=0.5, binwidth=10)
p1.2u + facet_wrap(~year_factor) + labs(title="Species-level half cover date")

# this will just show sampling date artifact
p2 <- ggplot(data = green_kbsp, aes(x = min_green_date, fill=state)) + geom_histogram(alpha=0.5, binwidth=10)
p2 + facet_wrap(~year_factor)

# Density plot
p3 <- ggplot(data = green_kbsp, aes(x = plot_half_cover_date, fill=state)) + geom_density(alpha=0.5)
p3 + facet_wrap(~year_factor) + labs(title="Plot-level half cover date")

p3.2 <- ggplot(data = green_kbs, aes(x = spp_half_cover_date, fill=state)) + geom_density(alpha=0.5)
p3.2 + facet_wrap(~year_factor) + labs(title="Species-level half cover date")

p3u <- ggplot(data = green_umbsp, aes(x = plot_half_cover_date, fill=state)) + geom_density(alpha=0.5)
p3u + facet_wrap(~year_factor) + labs(title="Plot-level half cover date")

p3.2u <- ggplot(data = green_umbs, aes(x = spp_half_cover_date, fill=state)) + geom_density(alpha=0.5)
p3.2u + facet_wrap(~year_factor) + labs(title="Species-level half cover date")

# this will just show sampling date artifact
p4 <- ggplot(data = green_kbsp, aes(x = min_green_date, fill=state)) + geom_density(alpha=0.5)
p4 + facet_wrap(~year_factor)

# looks like the 225 spike is from 2018 and 2020 - what's going on here is that you are treating all species-plot records as independent observations, so the influence of species differences is likely coming through here.
kbs_2018 <- subset(green_kbs, year == 4) # many records on 235
kbs_2020 <- subset(green_kbs, year == 6) # records from 227 & 228
```

\pagebreak

# Leverage plots and detecting Outliers. https://www.statmethods.net/stats/rdiagnostics.html
# These illustrate whether certain data points have more leverage (more influence), and thus could be outliers. It's a way of detecting outliers. Leverage plots can help identify whether a point has high or low influence, based on its leverage and residual and determining model fit with and without the point in question. Ultimately you decide whether the points are outliers or not, based on the knowledge of the system and how much it changes the model when included vs. excluded from the data used to fit the model. Here is a good overview of the combination of leverage and residual: scroll down to sections beginning at "13.3 Unusual Observations": https://daviddalpiaz.github.io/appliedstats/model-diagnostics.html
```{r}
# checking fit for date as a function of state/species/year - bringing in species here makes it obvious that that is explaining some of the variation compared with the state-only model you had previously.

### species-level data ###
# KBS State-only model
fit<- lm(spp_half_cover_date~state, data = green_kbs)
outlierTest(fit) # no outliers
qqPlot(fit, main="QQ Plot") 
hist(fit$residuals)
leveragePlots(fit)

# KBS State and species model 
fit1 <- lm(spp_half_cover_date~state + species, data = green_kbs)
outlierTest(fit1) # no outliers
hist(fit1$residuals)
qqPlot(fit1, main="QQ Plot") 
leveragePlots(fit1)
ols_test_normality(fit1) # p < 0.05 for all, so data is normal (I think? Is this function useful?)

# UMBS State and species model 
fit1umbs <- lm(spp_half_cover_date~state + species, data = green_umbs)
outlierTest(fit1umbs) # no outliers
hist(fit1umbs$residuals)
qqPlot(fit1umbs, main="QQ Plot") 
leveragePlots(fit1umbs)
ols_test_normality(fit1umbs)

fit1a <- lm(min_green_date~state + species, data = green_kbs)
outlierTest(fit1a) # no outliers
hist(fit1a$residuals)
qqPlot(fit1a, main="QQ Plot") 
leveragePlots(fit1a)

# KBS: checking fit for date as a function of state and year
fit2 <- lm(spp_half_cover_date~state+species+year_factor, data = green_kbs)
hist(fit2$residuals)
outlierTest(fit2) # no outliers
qqPlot(fit2, main="QQ Plot") 
leveragePlots(fit2)
ols_test_normality(fit2)


### plot level data ###
# KBS State-only model
fitp<- lm(plot_half_cover_date~state, data = green_kbsp)
outlierTest(fitp) # no outliers
qqPlot(fitp, main="QQ Plot") 
hist(fitp$residuals)
leveragePlots(fitp)
# Check for homogeneity of variances (true if p>0.05). If the result is not significant, the assumption of equal variances (homoscedasticity) is met (no significant difference between the group variances).
leveneTest(residuals(fitp) ~ green_kbsp$state)
ols_test_normality(fitp)
shapiro.test(resid(fitp))

fitp2<- lm(med_half_cover_date~state, data = green_kbsp2)
outlierTest(fitp2) # one outlier - 85; leaving for now because it seems true
#green_kbsp2 <- green_kbsp2[-(85),] # removing the outlier
qqPlot(fitp2, main="QQ Plot") 
hist(fitp2$residuals)
leveragePlots(fitp2)
leveneTest(residuals(fitp2) ~ green_kbsp2$state)
ols_test_normality(fitp2)
shapiro.test(resid(fitp2))

# UMBS State-only model
fitpu<- lm(plot_half_cover_date~state, data = green_umbsp)
outlierTest(fitpu) # no outliers
qqPlot(fitpu, main="QQ Plot") 
hist(fitpu$residuals)
leveragePlots(fitpu)
leveneTest(residuals(fitpu) ~ green_umbsp$state)
ols_test_normality(fitpu)
shapiro.test(resid(fitpu))

fitpu2<- lm(med_half_cover_date~state, data = green_umbsp2)
outlierTest(fitpu2) # no outliers
qqPlot(fitpu2, main="QQ Plot") 
hist(fitpu2$residuals)
leveragePlots(fitpu2)
leveneTest(residuals(fitpu2) ~ green_umbsp2$state)
ols_test_normality(fitpu2)
shapiro.test(resid(fitpu2))

# KBS State and year model
fitp_y<- lm(plot_half_cover_date~state+year_factor, data = green_kbsp)
outlierTest(fitp_y) # no outliers
qqPlot(fitp_y, main="QQ Plot") 
hist(fitp_y$residuals)
leveragePlots(fitp_y)
leveneTest(residuals(fitp_y) ~ green_kbsp$state)
leveneTest(residuals(fitp_y) ~ green_kbsp$year_factor) # doesn't work with numerical year
ols_test_normality(fitp_y)
shapiro.test(resid(fitp_y))

fitp2_y<- lm(med_half_cover_date~state+year_factor, data = green_kbsp2)
outlierTest(fitp2_y) # no outliers
qqPlot(fitp2_y, main="QQ Plot") 
hist(fitp2_y$residuals)
leveragePlots(fitp2_y)
leveneTest(residuals(fitp2_y) ~ green_kbsp2$state)
leveneTest(residuals(fitp2_y) ~ green_kbsp2$year_factor) # doesn't work with numerical year
ols_test_normality(fitp2_y)
shapiro.test(resid(fitp2_y))

# UMBS State and year model
fitpu_y<- lm(plot_half_cover_date~state+year, data = green_umbsp)
outlierTest(fitpu_y)
qqPlot(fitpu_y, main="QQ Plot") 
hist(fitpu_y$residuals)
leveragePlots(fitpu_y)
leveneTest(residuals(fitpu_y) ~ green_umbsp$state)
ols_test_normality(fitpu_y)
shapiro.test(resid(fitpu_y))

fitpu2_y<- lm(med_half_cover_date~state+year, data = green_umbsp2)
outlierTest(fitpu2_y)
qqPlot(fitpu2_y, main="QQ Plot") 
hist(fitpu2_y$residuals)
leveragePlots(fitpu2_y)
leveneTest(residuals(fitpu2_y) ~ green_umbsp2$state)
ols_test_normality(fitpu2_y)
shapiro.test(resid(fitpu2_y))


### trying transformations
# note: the greenup v2 data is normal and doesn't need transformed
# KBS State and year model - reciprocal transformation
fitp2_trans<- lm(1/(plot_half_cover_date)~state+year_factor, data = green_kbsp)
outlierTest(fitp2_trans) # no outliers
qqPlot(fitp2_trans, main="QQ Plot") 
hist(fitp2_trans$residuals)
leveragePlots(fitp2_trans)
leveneTest(residuals(fitp2_trans) ~ green_kbsp$state)
leveneTest(residuals(fitp2_trans) ~ green_kbsp$year_factor) # doesn't work with numerical year
shapiro.test(resid(fitp2_trans))

# UMBS State and year model - reciprocal transformation
fitu2_trans<- lm(1/(plot_half_cover_date)~state+year_factor, data = green_umbsp)
outlierTest(fitu2_trans) # no outliers
qqPlot(fitu2_trans, main="QQ Plot") 
hist(fitu2_trans$residuals)
leveragePlots(fitu2_trans)
leveneTest(residuals(fitu2_trans) ~ green_umbsp$state)
leveneTest(residuals(fitu2_trans) ~ green_umbsp$year_factor) # doesn't work with numerical year
shapiro.test(resid(fitu2_trans))
```

\pagebreak

# Normal distribution after accounting for species and/or year for each site and model. Set up some linear mixed effects models to evaluate. From Ben Bolker: "The traditional view of random effects is as a way to do correct statistical tests when some observations are correlated. ... Random effects are especially useful when we have (1) lots of levels (e.g., many species or blocks), (2) relatively little data on each level (although we need multiple samples from most of the levels), and (3) uneven sampling across levels. People sometimes say that random effects are “factors that you aren’t interested in.” This is not always true. While it is often the case in ecological experiments (where variation among sites is usually just a nuisance), it is sometimes of great interest." In our case, variation among plots is a nuisance, and not something we're interested in. For some questions, variation among species is also a nuisance for us. It's possible that variation among years is a nuisance if we only care about warm vs. ambient, but I think time is an interesting variable to consider with this study. 

# We should also think about how we're treating year. Some of the models have a state * year interaction as a fixed effect, which means that the warming or ambient treatment could affect the half_cover_date differently over time (there would be a different slope for each state in the relationship between half_cover_date (y) and year (x)). If we just had state + year, the states would have the same slope, indicating that they have no interaction in their effect on half_cover_date (but they could still have different intercepts).

```{r}
# Interaction plot (ignore for now the repeated measures with species); see: https://cran.r-project.org/web/packages/interactions/vignettes/interactions.html and: https://interactions.jacob-long.com/

# KBS
# plot half cover
fit3 <- lm(1/(plot_half_cover_date) ~ state + year, data = green_kbsp)
interact_plot(fit3, pred = year, modx = state)
fit4 <- lm(1/(plot_half_cover_date) ~ state * year, data = green_kbsp)
interact_plot(fit4, pred = year, modx = state)
fit3.2 <- lm(med_half_cover_date ~ state + year, data = green_kbsp2)
interact_plot(fit3.2, pred = year, modx = state)
fit4.2 <- lm(med_half_cover_date ~ state * year, data = green_kbsp2)
interact_plot(fit4.2, pred = year, modx = state)

# species half cover
fit5 <- lm(spp_half_cover_date ~ state + year + species, data = green_kbs)
interact_plot(fit5, pred = year, modx = state)
fit6 <- lm(spp_half_cover_date ~ state * year + species, data = green_kbs)
interact_plot(fit6, pred = year, modx = state, mod2 = species)

# species first date of green-up
fit7 <- lm(min_green_date ~ state + year + species, data = green_kbs)
interact_plot(fit7, pred = year, modx = state)
fit8 <- lm(min_green_date ~ state * year + species, data = green_kbs)
interact_plot(fit8, pred = year, modx = state, mod2 = species)

# UMBS
# plot half cover date
fit3u <- lm(1/(plot_half_cover_date) ~ state + year, data = green_umbsp)
interact_plot(fit3u, pred = year, modx = state)
fit4u <- lm(1/(plot_half_cover_date) ~ state * year, data = green_umbsp)
interact_plot(fit4u, pred = year, modx = state)

# species half cover date
fit5u <- lm(spp_half_cover_date ~ state + year + species, data = green_umbs)
interact_plot(fit5u, pred = year, modx = state)
fit6u <- lm(spp_half_cover_date ~ state * year + species, data = green_umbs)
interact_plot(fit6u, pred = year, modx = state, mod2 = species)

# species first date of green-up
fit7u <- lm(min_green_date ~ state + year + species, data = green_umbs)
interact_plot(fit7u, pred = year, modx = state)
fit8u <- lm(min_green_date ~ state * year + species, data = green_umbs)
interact_plot(fit8u, pred = year, modx = state, mod2 = species)
```

KBS Species-level Mixed Effects Models:
```{r}
# Start by replicating (almost) what we did in the Oecologia 2018 paper. The only difference here is that we have multiple years, so we are also including year as a fixed effect and as an interactive term. Our goal here is to find a model that is the best fit to the data. We also want to find a model that is the most parsimonious (one that has the fewest parameters).


## Note: KD re-ran different models below, these are models by PLZ
# Do we need to include plot as a random effect with the KBS models?   
mod1 <- lmer(spp_half_cover_date ~ state*year_factor + insecticide*year_factor + (1|species) + (1|plot), green_kbs, REML=FALSE)
mod2 <- lmer(spp_half_cover_date ~ state*year_factor + insecticide*year_factor + (1|species), green_kbs, REML=FALSE)
# Run analysis of variance on each model (see this for more explanation on how anova on a linear mixed effects model is similar to an anove on a regular linear model: https://m-clark.github.io/docs/mixedModels/anovamixed.html)
anova(mod1)
anova(mod2)

# Run an ANOVA to test if 2 models to test whether the more complex model is significantly better at capturing the data than the simpler model. If the resulting p-value is sufficiently low (usually less than 0.05), we conclude that the more complex model is significantly better than the simpler model, and thus favor the more complex model. If the p-value is not sufficiently low (usually greater than 0.05), we should favor the simpler model. https://bookdown.org/ndphillips/YaRrr/comparing-regression-models-with-anova.html
anova(mod2, mod1) # favor mod 2
summary(mod1) 
summary(mod2)

# Next, plot the model. There are multiple variables but here's one way to do it based on this package sjPlot:
# https://strengejacke.github.io/sjPlot/articles/plot_model_estimates.html
# Annoyingly, this package somehow overwrites the factor order in its plotting so we will have to modify the code to get warmed = red. I haven't figured this out yet. It does seem to work on some of the plots. hmm.
#?plot_model
# Plot the fixed effects estimates for different models
# these are the fixed effects estimates from summary(mod5)
plot_model(mod2, sort.est = TRUE)
# these are the fixed predicted values:
plot_model(mod2, type = "pred", terms = c("year_factor", "state", "insecticide"))
# these are the random effects estimates
plot_model(mod2, type = "re", terms = c("species"))

# Do we need to include insecticide? 
mod3 <- lmer(spp_half_cover_date ~ state*year_factor + (1|species), green_kbs, REML=FALSE)
anova(mod2, mod3)
AICctab(mod2, mod3, weights=T)
# Dont' need insecticide, continue with mod3

# Does year need to be interactive with insecticide? - already removed insecticide
mod4 <- lmer(spp_half_cover_date ~ state*year_factor + insecticide + (1|species) + (1|plot), green_kbs, REML=FALSE)
anova(mod2, mod4)
## No, P>0.05 so insecticide*year doesn't strongly improve model fit so we will shift to mod4
anova(mod3, mod4)
# Still continue with no insecticide model 3

# Does year need to be interactive with state?
mod5 <- lmer(spp_half_cover_date ~ state + year_factor + (1|species), green_kbs, REML=FALSE)
anova(mod3, mod5)
AICctab(mod3, mod5, weights=T)
# state*year doesn't improve model fit so we could drop it and go with mod5
summary(mod5)

# these are the fixed effects estimates from summary(mod3)
plot_model(mod5, sort.est = TRUE)
# these are the fixed predicted values:
plot_model(mod3, type = "pred", terms = c("year_factor", "state"))
# these are the random effects estimates
plot_model(mod3, type = "re", terms = c("species", "plot"))

# If we wanted to include plots nested within year it would look like this:
mod6 <- lmer(spp_half_cover_date ~ state*year_factor + (1|species) + (1+year|plot), green_kbs, REML=FALSE)
anova(mod5, mod6)
# mod 5 still better fit
plot_model(mod5, sort.est = TRUE)
# these are the fixed predicted values:
plot_model(mod5, type = "pred", terms = c("year_factor", "state"))
# these are the random effects estimates
plot_model(mod5, type = "re", terms = c("species", "plot"))

# mod5 (and mod6) are pretty complex in terms of interpretation (they actually don't have many parameters though). We could consider an alternative model that's simpler to understand and also one that provides more insight about the species.

# including species as fixed effect
mod7 <- lmer(spp_half_cover_date ~ state + species + (1+year_factor|plot), green_kbs, REML=FALSE)
mod7a <- lmer(spp_half_cover_date ~ state + species + year_factor + (1|plot), green_kbs, REML=FALSE)
mod7b <- lmer(spp_half_cover_date ~ state * year_factor + species + (1|plot), green_kbs, REML=FALSE)
mod7c <- lmer(spp_half_cover_date ~ state + species + year_factor + insecticide + (1|plot), green_kbs, REML=FALSE)
anova(mod6, mod7) # model 7 is a better fit to data
anova(mod7, mod7a) #mod 7a - but why is p = 1?
anova(mod7a, mod7b) #mod 7a
anova(mod7a, mod7c) #mod 7a
summary(mod7a)
anova(mod7a) # investigates whether at least one of the levels within each factor is significantly different.
# Yes, at least one of the species is different (they do not all have the same half cover dates). 
emmeans(mod7a, list(pairwise ~ state+year_factor), adjust = "tukey")
emmeans(mod7a, list(pairwise ~ year_factor), adjust = "tukey")
emmeans(mod7a, list(pairwise ~ species), adjust = "tukey")

# Take a look at the estimates for each fixed effect. These are the estimates from summary(mod7a). You'll see that species vary a lot - and many of them are different from zero (meaning their half cover date is significantly different from zero).
plot_model(mod7a, sort.est = TRUE)
# if you want to standardize the estimates:
plot_model(mod7a, sort.est = TRUE, type="std") 
# these are the fixed predicted values: - note this is a new plot
plot_model(mod7a, type = "pred", terms = c("species", "state", "year_factor"))
# these are the random effects estimates
plot_model(mod7a, type = "re")


# Start KD models - listed out possible models all at once, then compared (some of these are duplicates of models above):
# KD: I did this just to sort out (in my mind) model formulation with diff combos of effects - not the best method here
mod_kd1 <- lmer(spp_half_cover_date ~ state + (1|plot), green_kbs, REML=FALSE)
mod_kd2 <- lmer(spp_half_cover_date ~ state + (1|year_factor), green_kbs, REML=FALSE)
mod_kd3 <- lmer(spp_half_cover_date ~ state + (1+year_factor|plot), green_kbs, REML=FALSE)
mod_kd4 <- lmer(spp_half_cover_date ~ state + year_factor + (1|plot), green_kbs, REML=FALSE)
mod_kd4 <- lmer(spp_half_cover_date ~ state * year_factor + (1|plot), green_kbs, REML=FALSE)
mod_kd5 <- lmer(spp_half_cover_date ~ state + species + (1|plot), green_kbs, REML=FALSE)
mod_kd6 <- lmer(spp_half_cover_date ~ state * species + (1|plot), green_kbs, REML=FALSE)
mod_kd7 <- lmer(spp_half_cover_date ~ state + insecticide + (1|plot), green_kbs, REML=FALSE)
mod_kd8 <- lmer(spp_half_cover_date ~ state * insecticide + (1|plot), green_kbs, REML=FALSE)
mod_kd9 <- lmer(spp_half_cover_date ~ state + insecticide + species + (1|plot), green_kbs, REML=FALSE)
mod_kd10 <- lmer(spp_half_cover_date ~ state + insecticide + year_factor + (1|plot), green_kbs, REML=FALSE)
mod_kd11 <- lmer(spp_half_cover_date ~ state + year_factor + species + (1|plot), green_kbs, REML=FALSE)
mod_kd12 <- lmer(spp_half_cover_date ~ state + year_factor + species + insecticide + (1|plot), green_kbs, REML=FALSE)
mod_kd13 <- lmer(spp_half_cover_date ~ insecticide + (1|plot), green_kbs, REML=FALSE)
AICctab(mod_kd1, mod_kd2, mod_kd3, mod_kd4, mod_kd5, mod_kd6, mod_kd7, mod_kd8, mod_kd9, mod_kd10, mod_kd11, mod_kd12, mod_kd13, weights=T)
summary(mod_kd11)

# including native vs. exotic
# just swapped species out for origin, using the same model forms as above for species
green_kbs <- within(green_kbs, origin <- relevel(factor(origin), ref = "Native")) # releveling so native is the reference
mod8 <- lmer(spp_half_cover_date ~ state * origin + (1+year_factor|plot), green_kbs, REML=FALSE)
mod9 <- lmer(spp_half_cover_date ~ state + origin + (1+year_factor|plot), green_kbs, REML=FALSE)
mod9a <- lmer(spp_half_cover_date ~ state + origin + factor(year_factor) + (1|plot), green_kbs, REML=FALSE)
mod9b <- lmer(spp_half_cover_date ~ state + origin + insecticide + factor(year_factor) + (1|plot), green_kbs, REML=FALSE)
anova(mod8, mod9) # model 9 is a better fit to data
anova(mod9, mod9a) # mod 9a
anova(mod9a, mod9b) # mod 9a
summary(mod9a)
anova(mod9)
emmeans(mod9a, list(pairwise ~ state + origin), adjust = "tukey")

# including growth form - first with interaction term
green_kbs <- within(green_kbs, growth_habit <- relevel(factor(growth_habit), ref = "Forb")) # releveling so forb is the reference
mod10 <- lmer(spp_half_cover_date ~ state * growth_habit + (1+year_factor|plot), green_kbs, REML=FALSE)
mod11 <- lmer(spp_half_cover_date ~ state + growth_habit + (1+year_factor|plot), green_kbs, REML=FALSE)
mod11a <- lmer(spp_half_cover_date ~ state + growth_habit + factor(year_factor) + (1|plot), green_kbs, REML=FALSE)
mod11b <- lmer(spp_half_cover_date ~ state + growth_habit + insecticide + factor(year_factor) + (1|plot), green_kbs, REML=FALSE)
anova(mod10, mod11) # model 11 is a better fit to data
anova(mod11, mod11a) # model 11a
anova(mod11a, mod11b) # model 11a
summary(mod11a)
anova(mod11a)
emmeans(mod11a, list(pairwise ~ year_factor + growth_habit), adjust = "tukey")

# You could now run some post hoc tests on these (see: https://stats.stackexchange.com/questions/169543/output-of-fixed-effects-summary-in-lmertest-in-r-and-post-hoc-tests)

# Here are some other options for plotting these plots above: 
# https://stackoverflow.com/questions/31075407/plot-mixed-effects-model-in-ggplot

# Here's another approach:
# https://stats.stackexchange.com/questions/98958/plots-to-illustrate-results-of-linear-mixed-effect-model
# Not quite working yet:
#newdat <- expand.grid(state=unique(green_kbs$state),
#                  year=c(min(green_kbs$year),
#                            max(green_kbs$year)),
#                  insecticide=unique(green_kbs$insecticide))
#p <- ggplot(green_kbs, aes(x=year, y=spp_half_cover_date, colour=state, shape=insecticide)) +
#  geom_point(size=3) +
#  geom_line(aes(y=predict(mod5), group=species, size="species")) +
#  geom_line(data=newdat, aes(y=predict(mod5, level=0, newdata=newdat), size="Population")) +
#  scale_size_manual(name="Predictions", values=c("species"=0.5, "Population"=3)) +
#  #facet_wrap(~insecticide) +
#  theme_bw(base_size=22) 
#print(p)

# KD note: these models are included below in plot-level section
# New version of our model incorporating interaction term and species within year so that there is a separate intercept and slope for each species. The issue here is that there are some species that are not found each year. Easiest to remove those from another version of this dataframe before running below. Otherwise, it's not a balanced design.
# updated mod4
#mod12 <- lmer(spp_half_cover_date ~ state * year + (1+year|species), green_kbs)

# So another version of this model would include the interaction but not include the nesting (and thus would assume that species aren't observed ea yr)
# updated mod5
#mod13 <- lmer(spp_half_cover_date ~ state * year + (1|species), green_kbs)
```

# KBS Plot-level Mixed Effects Models:
```{r}
# testing if year as continuous or year as a factor makes more sense (test models)
year.mod.test1 <- lmer(1/(plot_half_cover_date) ~ state + year_factor+(1|plot), green_kbsp, REML=FALSE)
year.mod.test2 <- lmer(1/(plot_half_cover_date) ~ state + as.factor(year_factor)+(1|plot), green_kbsp, REML=FALSE)
anova(year.mod.test1,year.mod.test2)
# going to use year as a factor
# I also think this makes the most sense because I don't think we expect there to be a much of a trend over time for green-up; maybe if we had a longer time span, but I don't think 6 years is enough to detect a trend over time and the results will be more influenced by between year variation in temp, precip, etc.

# plot-level models using the re-summarized data frame
modfull <- lmer(1/(plot_half_cover_date) ~ state*as.factor(year_factor) + insecticide*as.factor(year_factor) + (1|plot), green_kbsp, REML=F)
mod1p <- lmer(1/(plot_half_cover_date) ~ state + (1|plot), green_kbsp, REML=FALSE)
mod2p <- lmer(1/(plot_half_cover_date) ~ insecticide + (1|plot), green_kbsp, REML=FALSE)
mod3p <- lmer(1/(plot_half_cover_date) ~ insecticide + state + (1|plot), green_kbsp, REML=FALSE)
mod4p <- lmer(1/(plot_half_cover_date) ~ insecticide * state + (1|plot), green_kbsp, REML=FALSE)
mod5p <- lmer(1/(plot_half_cover_date) ~ state + as.factor(year_factor) + (1|plot), green_kbsp, REML=FALSE)
mod6p <- lmer(1/(plot_half_cover_date) ~ state + as.factor(year_factor) + insecticide + (1|plot), green_kbsp, REML=FALSE)
mod7p <- lmer(1/(plot_half_cover_date) ~ state * as.factor(year_factor) + (1|plot), green_kbsp, REML=FALSE)
mod8p <- lmer(1/(plot_half_cover_date) ~ state * as.factor(year_factor) + insecticide + (1|plot), green_kbsp, REML=FALSE)
mod9p <- lmer(1/(plot_half_cover_date) ~ state * insecticide + as.factor(year_factor) + (1|plot), green_kbsp, REML=FALSE)
mod10p <- lmer(1/(plot_half_cover_date) ~ state + insecticide * as.factor(year_factor) + (1|plot), green_kbsp, REML=FALSE)
mod11p <- lmer(1/(plot_half_cover_date) ~ state * insecticide * as.factor(year_factor) + (1|plot), green_kbsp, REML=FALSE)
AICtab(modfull, mod1p, mod2p, mod3p, mod4p, mod5p, mod6p, mod7p, mod8p, mod9p, mod10p, mod11p, weights=T)
anova(modfull, mod1p) #modfull
anova(modfull, mod2p) #modfull
anova(modfull, mod3p) #modfull
anova(modfull, mod4p) #modfull
anova(modfull, mod5p) #mod5p
anova(mod5p, mod6p) #mod5p
anova(mod5p, mod7p) #mod7p
anova(mod7p, mod8p) #mod7p
anova(mod7p, mod9p) #mod9p 
anova(mod9p, mod10p) #mod9p
anova(mod9p, mod11p) #mod9p
table <- anova(mod9p, mod7p)
summary(mod9p)
anova(mod9p)

# note: this effect size calculation is for mod 5p
# calculating effect size - accounting for reciprocal transformation
1/(7.697e-03 + 4.575e-04*0) # 129.9207 ambient
1/(7.697e-03 + 4.575e-04*1) # 122.6317 warmed
# effect:
129.9207 - 122.6317 # warmed plots green-up 7.289 days earlier than ambient

# comparisons
emmeans(mod9p, list(pairwise ~ state*insecticide), adjust = "tukey")
mod9p.emm <- emmeans(mod9p, ~ insecticide * state)
contrast(mod9p.emm, "consec", simple = "each", combine = F, adjust = "mvt")
emmip(mod9p, insecticide~state)

# making a table with best-fit model and hypothesized model
kable(table) %>% kableExtra::kable_styling()



###### green-up V2 models #####
# testing if year as continuous or year as a factor makes more sense (test models)
year.mod.test1 <- lmer(med_half_cover_date ~ state + year_factor+(1|plot), green_kbsp2, REML=FALSE)
year.mod.test2 <- lmer(med_half_cover_date ~ state + as.factor(year_factor)+(1|plot), green_kbsp2, REML=FALSE)
anova(year.mod.test1,year.mod.test2)
# going to use year as a factor
# I also think this makes the most sense because I don't think we expect there to be a much of a trend over time for green-up; maybe if we had a longer time span, but I don't think 6 years is enough to detect a trend over time and the results will be more influenced by between year variation in temp, precip, etc.

# plot-level models using the re-summarized data frame
modfull <- lmer(med_half_cover_date ~ state*as.factor(year_factor) + insecticide*as.factor(year_factor) + (1|plot), green_kbsp2, REML=F)
mod1p <- lmer(med_half_cover_date ~ state + (1|plot), green_kbsp2, REML=FALSE)
mod2p <- lmer(med_half_cover_date ~ insecticide + (1|plot), green_kbsp2, REML=FALSE)
mod3p <- lmer(med_half_cover_date ~ insecticide + state + (1|plot), green_kbsp2, REML=FALSE)
mod4p <- lmer(med_half_cover_date ~ insecticide * state + (1|plot), green_kbsp2, REML=FALSE)
mod5p <- lmer(med_half_cover_date ~ state + as.factor(year_factor) + (1|plot), green_kbsp2, REML=FALSE)
mod6p <- lmer(med_half_cover_date ~ state + as.factor(year_factor) + insecticide + (1|plot), green_kbsp2, REML=FALSE)
mod7p <- lmer(med_half_cover_date ~ state * as.factor(year_factor) + (1|plot), green_kbsp2, REML=FALSE)
mod8p <- lmer(med_half_cover_date ~ state * as.factor(year_factor) + insecticide + (1|plot), green_kbsp2, REML=FALSE)
mod9p <- lmer(med_half_cover_date ~ state * insecticide + as.factor(year_factor) + (1|plot), green_kbsp2, REML=FALSE)
mod10p <- lmer(med_half_cover_date ~ state + insecticide * as.factor(year_factor) + (1|plot), green_kbsp2, REML=FALSE)
mod11p <- lmer(med_half_cover_date ~ state * insecticide * as.factor(year_factor) + (1|plot), green_kbsp2, REML=FALSE)

AICctab(modfull, mod1p, mod2p, mod3p, mod4p, mod5p, mod6p, mod7p, mod8p, mod9p, mod10p, mod11p,weights=T)

anova(modfull, mod1p) #modfull
anova(modfull, mod2p) #modfull
anova(modfull, mod3p) #modfull
anova(modfull, mod4p) #modfull
anova(modfull, mod5p) #modfull
anova(modfull, mod6p) #modfull
anova(modfull, mod7p) #mod7p
anova(mod7p, mod8p) #mod8p
anova(mod8p, mod9p) #mod8p (note: 9p is hypothesized model)
anova(mod8p, mod10p) #mod8p
anova(mod8p, mod11p) #mod8p

table <- anova(mod8p, mod9p)
summary(mod8p)
anova(mod8p)

# comparisons
emmeans(mod8p, list(pairwise ~ state*year_factor), adjust = "tukey")
mod8p.emm <- emmeans(mod8p, ~ state*year_factor)
contrast(mod8p.emm, "consec", simple = "each", combine = F, adjust = "mvt")
emmip(mod8p, insecticide~state)

# making a table with best-fit model and hypothesized model
kable(table) %>% kableExtra::kable_styling()
AICctab(mod8p,mod9p)

# adding in our temp data into some models
# note: including state, year, and temp data into a model leads to rank deficiency
# so below, we test for green-up as a function of just temp to see how real temp data affects green-up
modtest1 <- lmer(med_half_cover_date ~ mean_temp + (1|plot), green_kbsp2, REML=FALSE)
modtest2 <- lmer(med_half_cover_date ~ GDD_cumulative + (1|plot), green_kbsp2, REML=FALSE)

AICtab(modtest1,modtest2)

anova(modtest1)
summary(modtest1)

```

# Analyses for species who reached half cover within the green-up observation window
```{r}
# KD note: didn't use these analyses for anything
# Selecting species (these were determined in the half_cover_kbs dataframe made in the phenology_dates_L2.R script)
species_kbs <- subset(green_kbs, species == "Taof") # can change/add more species 
mod_spp <- lmer(spp_half_cover_date ~ state + factor(year_factor) + (1|plot), species_kbs, REML=FALSE)
mod_spp2 <- lmer(min_green_date ~ state + factor(year_factor) + (1|plot), species_kbs, REML=FALSE)
summary(mod_spp)
summary(mod_spp2)
```


# UMBS Mixed Effects Models
```{r}
# umod4 (and umod6) are pretty complex in terms of interpretation (they actually don't have many parameters though). We could consider an alternative umodel that's simpler to understand and also one that provides more insight about the species. That would be something like this:
umod7 <- lmer(spp_half_cover_date ~ state + species + (1+year_factor|plot), green_umbs, REML=FALSE)
umod7a <- lmer(spp_half_cover_date ~ state + species + year_factor + (1|plot), green_umbs, REML=FALSE)
umod7b <- lmer(spp_half_cover_date ~ state * year_factor + species + (1|plot), green_umbs, REML=FALSE)
umod7c <- lmer(spp_half_cover_date ~ state + species + year_factor + insecticide + (1|plot), green_umbs, REML=FALSE)
#anova(umod6, umod7) # umodel 7 is a better fit to data
anova(umod7, umod7a) #umod 7a
anova(umod7a, umod7b) #umod 7a
anova(umod7a, umod7c) #umod 7a
summary(umod7a)
summary(umod7b)
summary(umod7c)
anova(umod7a) # investigates whether at least one of the levels within each factor is significantly different. 
# Yes, at least one of the species is different (they do not all have the same half cover dates). 
emmeans(umod7a, list(pairwise ~ year_factor), adjust = "tukey")
emmeans(umod7a, list(pairwise ~ species), adjust = "tukey")


# including native vs. exotic - first with interaction term
green_umbs <- within(green_umbs, origin <- relevel(factor(origin), ref = "Native")) # releveling so native is the reference
umod8 <- lmer(spp_half_cover_date ~ state * origin + (1+year_factor|plot), green_umbs, REML=FALSE)
umod9 <- lmer(spp_half_cover_date ~ state + origin + (1+year_factor|plot), green_umbs, REML=FALSE)
umod9a <- lmer(spp_half_cover_date ~ state + origin + factor(year_factor) + (1|plot), green_umbs, REML=FALSE)
anova(umod8, umod9) # umodel 9 is a better fit to data
anova(umod9, umod9a) # umod 9a?
summary(umod9a)
anova(umod9)
emmeans(umod9a, list(pairwise ~ state + origin), adjust = "tukey")


# including growth form - first with interaction term
green_umbs <- within(green_umbs, growth_habit <- relevel(factor(growth_habit), ref = "Forb")) # releveling so forb is the reference
umod10 <- lmer(spp_half_cover_date ~ state * growth_habit + (1+year_factor|plot), green_umbs, REML=FALSE)
umod11 <- lmer(spp_half_cover_date ~ state + growth_habit + (1+year_factor|plot), green_umbs, REML=FALSE)
umod11a <- lmer(spp_half_cover_date ~ state + growth_habit + year_factor + (1|plot), green_umbs, REML=FALSE)
anova(umod10, umod11) # umodel 11 is a better fit to data
anova(umod11, umod11a)
summary(umod11a)
anova(umod11)
emmeans(umod11a, list(pairwise ~ state + growth_habit), adjust = "tukey")
```

# UMBS Plot-level Mixed Effects Models:
```{r}
# testing if year as continuous or year as a factor makes more sense (test models)
year.mod.test1u <- lmer(1/(plot_half_cover_date) ~ state + year_factor+(1|plot), green_umbsp, REML=FALSE)
year.mod.test2u <- lmer(1/(plot_half_cover_date) ~ state + as.factor(year_factor)+(1|plot), green_umbsp, REML=FALSE)
anova(year.mod.test1u,year.mod.test2u)
# going to use year as a factor

# plot-level models using the re-summarized data frame
modfull_u <- lmer(1/(plot_half_cover_date) ~ state*as.factor(year_factor) + insecticide*as.factor(year_factor) + (1|plot), green_umbsp, REML=F)
mod1p_u <- lmer(1/(plot_half_cover_date) ~ state + (1|plot), green_umbsp, REML=FALSE)
mod2p_u <- lmer(1/(plot_half_cover_date) ~ insecticide + (1|plot), green_umbsp, REML=FALSE)
mod3p_u <- lmer(1/(plot_half_cover_date) ~ insecticide + state + (1|plot), green_umbsp, REML=FALSE)
mod4p_u <- lmer(1/(plot_half_cover_date) ~ insecticide * state + (1|plot), green_umbsp, REML=FALSE)
mod5p_u <- lmer(1/(plot_half_cover_date) ~ state + as.factor(year_factor) + (1|plot), green_umbsp, REML=FALSE)
mod6p_u <- lmer(1/(plot_half_cover_date) ~ state + as.factor(year_factor) + insecticide + (1|plot), green_umbsp, REML=FALSE)
mod7p_u <- lmer(1/(plot_half_cover_date) ~ state * as.factor(year_factor) + (1|plot), green_umbsp, REML=FALSE)
mod8p_u <- lmer(1/(plot_half_cover_date) ~ state * as.factor(year_factor) + insecticide + (1|plot), green_umbsp, REML=FALSE)
mod9p_u <- lmer(1/(plot_half_cover_date) ~ state * insecticide + as.factor(year_factor) + (1|plot), green_umbsp, REML=FALSE)
mod10p_u <- lmer(1/(plot_half_cover_date) ~ state + insecticide * as.factor(year_factor) + (1|plot), green_umbsp, REML=FALSE)
mod11p_u <- lmer(1/(plot_half_cover_date) ~ state * insecticide * as.factor(year_factor) + (1|plot), green_umbsp, REML=FALSE)
AICtab(modfull_u, mod1p_u, mod2p_u, mod3p_u, mod4p_u, mod5p_u, mod6p_u, mod7p_u, mod8p_u, mod9p_u, mod10p_u, mod11p_u, weights=T)
anova(modfull_u, mod1p_u) #modfull
anova(modfull_u, mod2p_u) #modfull
anova(modfull_u, mod3p_u) #modfull
anova(modfull_u, mod4p_u) #modfull
anova(modfull_u, mod5p_u) #mod5p
anova(mod5p_u, mod6p_u) #mod5p
anova(mod5p_u, mod7p_u) #mod5p
anova(mod5p_u, mod8p_u) #mod5p
anova(mod5p_u, mod9p_u) #mod5p
anova(mod5p_u, mod10p_u) #mod5p
anova(mod5p_u, mod11p_u) #mod5p
table2 <- anova(mod9p_u, mod7p_u)
summary(mod5p_u)
anova(mod5p_u)
emmeans(mod7p_u, list(pairwise ~ state*as.factor(year_factor)), adjust = "tukey")
# the code below only works for models with state*year
mod7p_u.emm <- emmeans(mod7p_u, ~ state * year_factor)
contrast(mod7p_u.emm, "consec", simple = "each", combine = F, adjust = "mvt")
emmip(mod7p_u, year_factor~state)

# comparing models in a table output
# making a table with best-fit model and hypothesized model
kable(table2) %>% kableExtra::kable_styling()



##### green-u V2 models #####
# testing if year as continuous or year as a factor makes more sense (test models)
year.mod.test1u <- lmer(med_half_cover_date ~ state + year_factor+(1|plot), green_umbsp2, REML=FALSE)
year.mod.test2u <- lmer(med_half_cover_date ~ state + as.factor(year_factor)+(1|plot), green_umbsp2, REML=FALSE)
anova(year.mod.test1u,year.mod.test2u)
# going to use year as a factor

# plot-level models using the re-summarized data frame
modfull_u <- lmer(med_half_cover_date ~ state*as.factor(year_factor) + insecticide*as.factor(year_factor) + (1|plot), green_umbsp2, REML=F)
mod1p_u <- lmer(med_half_cover_date ~ state + (1|plot), green_umbsp2, REML=FALSE)
mod2p_u <- lmer(med_half_cover_date ~ insecticide + (1|plot), green_umbsp2, REML=FALSE)
mod3p_u <- lmer(med_half_cover_date ~ insecticide + state + (1|plot), green_umbsp2, REML=FALSE)
mod4p_u <- lmer(med_half_cover_date ~ insecticide * state + (1|plot), green_umbsp2, REML=FALSE)
mod5p_u <- lmer(med_half_cover_date ~ state + as.factor(year_factor) + (1|plot), green_umbsp2, REML=FALSE)
mod6p_u <- lmer(med_half_cover_date ~ state + as.factor(year_factor) + insecticide + (1|plot), green_umbsp2, REML=FALSE)
mod7p_u <- lmer(med_half_cover_date ~ state * as.factor(year_factor) + (1|plot), green_umbsp2, REML=FALSE)
mod8p_u <- lmer(med_half_cover_date ~ state * as.factor(year_factor) + insecticide + (1|plot), green_umbsp2, REML=FALSE)
mod9p_u <- lmer(med_half_cover_date ~ state * insecticide + as.factor(year_factor) + (1|plot), green_umbsp2, REML=FALSE)
mod10p_u <- lmer(med_half_cover_date ~ state + insecticide * as.factor(year_factor) + (1|plot), green_umbsp2, REML=FALSE)
mod11p_u <- lmer(med_half_cover_date ~ state * insecticide * as.factor(year_factor) + (1|plot), green_umbsp2, REML=FALSE)

AICtab(modfull_u, mod1p_u, mod2p_u, mod3p_u, mod4p_u, mod5p_u, mod6p_u, mod7p_u, mod8p_u, mod9p_u, mod10p_u, mod11p_u,weights=T)

anova(modfull_u, mod1p_u) #modfull
anova(modfull_u, mod2p_u) #modfull
anova(modfull_u, mod3p_u) #modfull
anova(modfull_u, mod4p_u) #modfull
anova(modfull_u, mod5p_u) #mod5p
anova(mod5p_u, mod6p_u) #mod6p
anova(mod6p_u, mod7p_u) #mod6p_u
anova(mod6p_u, mod8p_u) #mod6p_u
anova(mod6p_u, mod9p_u) #mod6p_u 
anova(mod6p_u, mod10p_u) #mod6p_u
anova(mod6p_u, mod11p_u) #mod11p_u

table <- anova(mod9p_u, mod6p_u)
summary(mod6p_u)
anova(mod9p_u)

# comparisons
emmeans(mod11p_u, list(pairwise ~ state*insecticide), adjust = "tukey")
mod9p.emm <- emmeans(mod9p_u, ~ state*insecticide)
contrast(mod9p.emm, "consec", simple = "each", combine = F, adjust = "mvt")
emmip(mod9p, insecticide~state)

# making a table with best-fit model and hypothesized model
kable(table) %>% kableExtra::kable_styling()
AICctab(mod6p_u,mod9p_u)


# adding in our temp data into some models
# note: including state, year, and temp data into a model leads to rank deficiency
# so below, we test for green-up as a function of just temp to see how real temp data affects green-up
modtest1u <- lmer(med_half_cover_date ~ mean_temp + (1|plot), green_umbsp2, REML=FALSE)
modtest2u <- lmer(med_half_cover_date ~ GDD_cumulative + (1|plot), green_umbsp2, REML=FALSE)

AICtab(modtest1u,modtest2u)

anova(modtest1u)
summary(modtest1u)
```

# KBS and UMBS in one model #
```{r}
# merging kbs and umbs V2 plot level data
green2 <- rbind(green_kbsp2,green_umbsp2)

# testing the effect of temp w/ both models
modtest_merge1 <- lmer(med_half_cover_date ~ mean_temp + (1|plot), green2, REML=FALSE)
modtest_merge2 <- lmer(med_half_cover_date ~ GDD_cumulative + (1|plot), green2, REML=FALSE)
modtest_merge3 <- lmer(med_half_cover_date ~ mean_temp + site + (1|plot), green2, REML=FALSE)
modtest_merge4 <- lmer(med_half_cover_date ~ GDD_cumulative + site + (1|plot), green2, REML=FALSE)

AICtab(modtest_merge1,modtest_merge2,modtest_merge3,modtest_merge4)
# does adding site help?
anova(modtest_merge1,modtest_merge3)
anova(modtest_merge2,modtest_merge4)

# the model w/ GDD performs the best
anova(modtest_merge2)
summary(modtest_merge2)


### just kbs
# testing the effect of temp w/ both models
modtest_merge1_kbs <- lmer(med_half_cover_date ~ mean_temp + (1|plot), green_kbsp2, REML=FALSE)
modtest_merge2_kbs <- lmer(med_half_cover_date ~ GDD_cumulative + (1|plot), green_kbsp2, REML=FALSE)

AICtab(modtest_merge1_kbs,modtest_merge2_kbs)

# the model w/ GDD performs the best
anova(modtest_merge2_kbs)
summary(modtest_merge1_kbs)


### just umbs
# testing the effect of temp w/ both models
modtest_merge1_umbs <- lmer(med_half_cover_date ~ mean_temp + (1|plot), green_umbsp2, REML=FALSE)
modtest_merge2_umbs <- lmer(med_half_cover_date ~ GDD_cumulative + (1|plot), green_umbsp2, REML=FALSE)

AICtab(modtest_merge1_umbs,modtest_merge2_umbs)

# the model w/ GDD performs the best
anova(modtest_merge1_umbs)
summary(modtest_merge1_umbs)
```


# *ORIGINAL CODE BELOW; not edited by Phoebe* ##
# can pretty much ignore everything below!

# Seeing what other distribution could fit
```{r}
descdist(green_kbs$spp_half_cover_date, discrete = FALSE)
```
# While uniform looks the closest, I'll try poisson
```{r, fig.align='center'}
fit <- lm(spp_half_cover_date~state, data = green_kbs)
residual <- fit$residuals
hist(residual, main="Raw residuals")  
pois <- glm(spp_half_cover_date~state, data = green_kbs, family="poisson")
hist(pois$residuals, main="Poisson glm residuals")
```

# Below I try a few different generalized linear models with poisson distribution:  
## An interaction between state and year, plus insecticide as a fixed effect and species and plot as random effects
```{r}
moda <- glmer(spp_half_cover_date ~ state*year + insecticide + (1|species) + (1|plot),
              data=green_kbs, family = poisson)
summary(moda)
```

## No interaction between state and year, but with state and insecticide as fixed effects and species and plot as random effects
```{r}
modb <- glmer(spp_half_cover_date ~ state + year + insecticide + (1|species) + (1|plot),
              data=green_kbs, family = poisson)
summary(modb)
```

## State and insecticide as fixed effects & year, species and plot as random effects
```{r, eval=FALSE}
modc <- glmer(spp_half_cover_date ~ state + insecticide + (1|year) + (1|species) + (1|plot),
              data=green_kbs, family = poisson)
summary(modc)
```

# Because no distributions seems to match well, I'll try a Friedman's test
```{r}
#friedman_kbs <- green_kbs %>% 
#  friedman_test(spp_half_cover_date ~ state)
```
## Error: Must extract column with a single valid subscript. x Subscript `var` can't be `NA`
## Can't figure out what this means  

## If I include the blocks portion of the formula (from the documentation) I get this error
```{r}
#friedman_kbs <- green_kbs %>% 
#  friedman_test(spp_half_cover_date ~ state | plot)
```
## Error in friedman.test.default(c(141L, 202L, 122L, 101L, 127L, 120L, 197L,  :  not an unreplicated complete block design

\pagebreak

# *UMBS*
# Checking for normality
```{r}
hist(green_umbs$spp_half_cover_date)
qqnorm(green_umbs$spp_half_cover_date)
shapiro.test(green_umbs$spp_half_cover_date)
hist(green_umbs$spp_half_cover_date[green_kbs$state == "ambient"])
hist(green_umbs$spp_half_cover_date[green_kbs$state == "warmed"])
```
## These look pretty good

# Trying log transformation
```{r}
green_umbs$date_log <- log(green_umbs$spp_half_cover_date)
hist(green_umbs$date_log)
shapiro.test(green_umbs$date_log)
```
## I think this looks good but shapiro-wilk is lower than 0.05

# Trying inverse tranformation
```{r}
green_umbs$date_inv <- 1/(green_umbs$spp_half_cover_date)
hist(green_umbs$date_inv)
shapiro.test(green_umbs$date_inv)
```
## This also looks good but is also still low for shapiro-wilk
---
title: "warmXtrophic Project: Plant Composition Diversity Data Analyses"
author: "Moriah Young, Pat Bills"
date: "`r format(Sys.time(), '%B %d, %Y')`"
output: pdf_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(knitr)
opts_chunk$set(tidy.opts=list(width.cutoff=80),tidy=TRUE)
```

# Load in packages & data
```{r, message = F}
# Clear all existing data
rm(list=ls())

#Load packages
library(tidyverse)
library(ggplot2)
library(lme4)
library(olsrr)
library(predictmeans)
library(car)
library(fitdistrplus)
library(ggpubr)
library(rstatix)
library(vegan)
library(interactions)
library(sjPlot)
library(effects)
library(glmmTMB)
library(labdsv) # used with Vegan package, the matrify() and matrify2() functions
library(agricolae) # HSD.test() function

# Set working directory
Sys.getenv("L1DIR")
L0_dir <- Sys.getenv("L0DIR")
L1_dir <- Sys.getenv("L1DIR")
L2_dir <- Sys.getenv("L2DIR")
list.files(L1_dir)

# read in plant comp data
comp <- read.csv(file.path(L1_dir, "plant_composition/final_plantcomp_L1.csv"))
comp <- comp %>% select(-X) # get rid of "X" column that shows up

# read in meta data
meta <- read.csv(file.path(L0_dir, "plot.csv")) # dataframe above already has meta data in it
```

```{r}
# adding sequential year variable starting at 1: this is because the years (e.g. 2015, 2016, etc) are large numbers compared with other values in the dataset. We can always label axes with these real years.
comp$year_factor[comp$year == 2015] <- 1
comp$year_factor[comp$year == 2016] <- 2
comp$year_factor[comp$year == 2017] <- 3
comp$year_factor[comp$year == 2018] <- 4
comp$year_factor[comp$year == 2019] <- 5
comp$year_factor[comp$year == 2020] <- 6
comp$year_factor[comp$year == 2021] <- 7

# Remove non-plant data
comp <- comp[!(comp$species=="Bare_Ground" | 
                       comp$species=="Unknown" | 
                       comp$species=="Brown" | 
                       comp$species=="Litter" | 
                       comp$species=="Vert_Litter" | 
                       comp$species=="Animal_Disturbance"), ]

```

```{r}
# Function to get data in wide format to work in Vegan package - taken from link below
# https://stackoverflow.com/questions/50691393/transform-community-data-into-wide-format-for-vegan-package

matrify2 <-  function(data) {
    #Data must have columns: plot, SPEC, abundance measure,Year
    if (ncol(data) != 4)
        stop("data frame must have four column format")
    plt <- factor(data[, 1])
    spc <- factor(data[, 2])
    abu <- data[, 3]
    yrs <- factor(data[, 4])
    plt.codes <- sort(levels(factor(plt)))##object with sorted plot numbers
    spc.codes <- levels(factor(spc))##object with sorted SPEC names
    yrs.codes <- sort(levels(factor(yrs)))##object with sorted sampling Years
    taxa <- matrix(0, nrow = length(plt.codes)*length(yrs.codes), ncol = length(spc.codes))##Create empty matrix with proper dimensions (unique(plotxYear) by # of SPEC)
    plt.list <- rep(plt.codes,length(yrs.codes))##Create a list of all the plot numbers (in order of input data) to add as an ID column at end of function
    yrs.list <- rep(yrs.codes,each=length(plt.codes))##Create a list of all the Year numbers (in order of input data) to add as an ID column at end of function
    col <- match(spc, spc.codes)##object that determines the alphabetical order ranking of each SPEC in the spc.code list
    row.plt <- match(plt, plt.codes)##object that determines the rank order ranking of each plot of the input data in the plt.code list
    row.yrs <- match(yrs,yrs.codes)##object that determines the rank order ranking of each Year of the input data in he #yrs.code list
    for (i in 1:length(abu)) {
        row <- (row.plt[i])+length(plt.codes)*(row.yrs[i]-1)##Determine row number by assuming each row represents a specific plot & year in an object of rep(plot,each=Year)
        if(!is.na(abu[i])) {##ONly use value if !is.na .. [ignore all is.NA values]
            taxa[row, col[i]] <- sum(taxa[row, col[i]], abu[i])##Add abundance measure of row i to the proper SPEC column and plot/Year row. Sum across all identical individuals.
        }
    }
    taxa <- data.frame(taxa)##Convert to data.frame for easier manipulation
    taxa <- cbind(yrs.list,plt.list,taxa)##Add ID columns for plot and Year to each row already representing the abundance of Each SPEC of that given plot/Year.
    names(taxa) <- c('Year','Plot',spc.codes)
    taxa
}
```


```{r}
#diversity_by_year <- function(comp, site, div_index = "shannon"){
comp_kbs <- subset(comp, site == "kbs") %>% dplyr::select(plot, species, cover, year)
comp_umbs <- subset(comp, site == "umbs") %>% dplyr::select(plot, species, cover, year)


# convert the abundance data to abundance for each species in columns for the vegan package
comp_kbs$cover <- as.numeric(comp_kbs$cover)
comp_wide_kbs <- matrify2(comp_kbs)
comp_umbs$cover <- as.numeric(comp_umbs$cover)
comp_wide_umbs <- matrify2(comp_umbs)

# comp_wide_data is assumes to have columns Year, Plot, and columns for each species found, e.g. for Vegan

# first, split up the wide data into a list of years.  Each list item is a year of data
comp_wide_by_year_kbs <- dplyr::group_by(comp_wide_kbs, Year) %>% dplyr::group_split()
comp_wide_by_year_umbs <- dplyr::group_by(comp_wide_umbs, Year) %>% dplyr::group_split()

# we need to add plot names.  Get those Plot names by taking a column from any one of the years
# since we are assuming the Plot column is the exact same across years and IN THE SAME ORDER
plot_names <- comp_wide_by_year_kbs[[1]]$Plot
plot_names <- comp_wide_by_year_umbs[[1]]$Plot

# remove the plot and year columns from each item in the list so that Vegan will work.
# This assumes row order is the exact same for all years (each row a plot)
comp_wide_by_year_kbs <- lapply(comp_wide_by_year_kbs, dplyr::select, c(-Year, -Plot))
comp_wide_by_year_umbs <- lapply(comp_wide_by_year_umbs, dplyr::select, c(-Year, -Plot))

#  apply  the diversity function to each year  - in this case the main index is plot, each year considered separately
diversity_by_year_list_kbs <- lapply(comp_wide_by_year_kbs,vegan::diversity, index = "shannon")
diversity_by_year_list_umbs <- lapply(comp_wide_by_year_umbs,vegan::diversity, index = "shannon")

# each item in the list is a year of diversity, so name those with the years we know we have
names(diversity_by_year_list_kbs) <- as.character(2015:2021)
names(diversity_by_year_list_umbs) <- as.character(2015:2021)

# "unlist" and create a new data frame, each year a column, each row a plot, and add a new row with the plot names
x_kbs <- do.call(cbind,diversity_by_year_list_kbs) %>% cbind(Plot = plot_names ) %>% as.data.frame()
x_umbs <- do.call(cbind,diversity_by_year_list_umbs) %>% cbind(Plot = plot_names ) %>% as.data.frame()
#  an alternative tidyverse way x<- diversity_by_year(diversity_by_year_list)

## optional step!
x_kbs
x_umbs

# comp$cover <- as.numeric(comp$cover)

# this output has a column for each year 2015, 2016, and Plot, but if you need it narrow use 'melt' from reshape2: 
library(reshape2)

#calculate shannon diversity
shannon_by_plot_year_kbs <- reshape2::melt(x_kbs, id =  "Plot", variable.name = c("Year"), value.name = "shannon")
shannon_by_plot_year_kbs$site <- "kbs" # adding site column
shannon_by_plot_year_umbs <- reshape2::melt(x_umbs, id =  "Plot", variable.name = c("Year"), value.name = "shannon") 
shannon_by_plot_year_umbs$site <- "umbs" # adding site column

#calculate simpson diversity
simpson_by_plot_year_kbs <- reshape2::melt(x_kbs, id =  "Plot", variable.name = c("Year"), value.name = "simpson") 
simpson_by_plot_year_kbs$site <- "kbs" # adding site column
simpson_by_plot_year_umbs <- reshape2::melt(x_umbs, id =  "Plot", variable.name = c("Year"), value.name = "simpson") 
simpson_by_plot_year_umbs$site <- "umbs" # adding site column

#combine umbs and kbs shannon diversity measures into 1 dataframe
shannon_diversity <- full_join(shannon_by_plot_year_kbs, shannon_by_plot_year_umbs, by = c("Plot", "Year", "shannon", "site"))

#combine umbs and kbs simpson diversity measures into 1 dataframe
simpson_diversity <- full_join(simpson_by_plot_year_kbs, simpson_by_plot_year_umbs, by = c("Plot", "Year", "simpson", "site"))

# combine simpson and shannon diversity data frames into 1
comp_diversity <- full_join(simpson_diversity, shannon_diversity, by = c("Plot", "Year", "site"))
# Looks like diversity and simpson diveristy measures are the same?? Need to look into this
```

KBS Simpson's Index
```{r}
#Data exploration
names(simpson_by_plot_year_kbs) <- tolower(names(simpson_by_plot_year_kbs)) # column names to lower case so I can combine this data frame with the meta data
simpson_by_plot_year_kbs <- full_join(simpson_by_plot_year_kbs, meta, by = c("plot")) # combine meta data with diversity data frame
simpson_by_plot_year_kbs$simpson <- as.numeric(simpson_by_plot_year_kbs$simpson)

hist(simpson_by_plot_year_kbs$simpson)
qqnorm(simpson_by_plot_year_kbs$simpson) # this looks good
shapiro.test(simpson_by_plot_year_kbs$simpson) # not normal 

# Exploring distributions for these slightly left-skewed data:
descdist(simpson_by_plot_year_kbs$simpson, discrete = FALSE) # log normal looks like a good fit
```
```{r}
# KBS State-only model
simpson_by_plot_year_kbs <- simpson_by_plot_year_kbs[-167,] # remove row with zero - won't be able to take the log of the simpson column if there is a zero in the column - this zero is from their not being any data in this plot due to a large ground hog hole
fit_state_kbs <- lm(log(simpson) ~ state, data = simpson_by_plot_year_kbs)
outlierTest(fit_state_kbs) 
qqPlot(fit_state_kbs, main="QQ Plot") 
hist(fit_state_kbs$residuals)
leveragePlots(fit_state_kbs)
ols_test_normality(fit_state_kbs)

# KBS State and year model
fit_stateyear_kbs <- lm(log(simpson) ~ state + year, data = simpson_by_plot_year_kbs)
outlierTest(fit_stateyear_kbs) # no outliers
qqPlot(fit_stateyear_kbs, main="QQ Plot") 
hist(fit_stateyear_kbs$residuals)
leveragePlots(fit_stateyear_kbs)
ols_test_normality(fit_stateyear_kbs)

# Interaction plot (ignore for now the repeated measures with species); see: https://cran.r-project.org/web/packages/interactions/vignettes/interactions.html and: https://interactions.jacob-long.com/

# I can't get these to work
#fit3 <- lm(log(simpson) ~ state + year, data = simpson_by_plot_year_kbs)
#interact_plot(fit3, pred = year, modx = state)
#fit4 <- lm(log(simpson) ~ state * year, data = simpson_by_plot_year_kbs)
#interact_plot(fit4, pred = year, modx = state, mod2 = species)
```

```{r}
mod1 <- lmer(log(simpson) ~ state*year + insecticide*year + (1|plot), simpson_by_plot_year_kbs, REML = FALSE)

# Check Assumptions:
# (1) Linearity: if covariates are not categorical (year isn't)
# (2) Homogeneity: Need to Check by plotting residuals vs predicted values.
par(mfrow=c(1,2))
plot(mod1)
# Homogeneity of variance is ok here (increasing variance in resids is not increasing with fitted values)
# Check for homogeneity of variances (true if p>0.05). If the result is not significant, the assumption of equal variances (homoscedasticity) is met (no significant difference between the group variances).
# *****Levene’s Test - tests whether or not the variance among two or more groups is equal - If the p-value is less than our chosen significance level, we can reject the null hypothesis and conclude that we have enough evidence to state that the variance among the groups is not equal (which we want).

leveneTest(residuals(mod1) ~ simpson_by_plot_year_kbs$state)
# Assumption not met
leveneTest(residuals(mod1) ~ simpson_by_plot_year_kbs$insecticide) 
# Assumption not met 
leveneTest(residuals(mod1) ~ simpson_by_plot_year_kbs$plot)
# Assumption not met

# (3) Normality of error term: need to check by histogram, QQplot of residuals, could do Kolmogorov-Smirnov test.
# Check for normal residuals
qqPlot(resid(mod1))
hist(residuals(mod1))
shapiro.test(resid(mod1)) # ormally distributed resids bc p>0.05
outlierTest(mod1) # no outliers

# (4) Normality of random effect: Get the estimate of random effect (e.g., random intercepts), and check them as you would check the residual. 
require(lme4)
r_int<- ranef(mod1)$plot$`(Intercept)`
qqnorm(r_int)
qqline(r_int)
shapiro.test(r_int) 
# Normally distributed random effect pvalue > 0.05
```

```{r}
# Do we need to include plot as a random effect with the UMBS models?   
mod1 <- lmer(log(simpson) ~ state*year + insecticide*year + (1|plot), simpson_by_plot_year_kbs, REML = FALSE)
mod2 <- lmer(log(simpson) ~ state*year + insecticide*year + (1|plot), simpson_by_plot_year_kbs, REML=FALSE)
# Run analysis of variance on each model (see this for more explanation on how anova on a linear mixed effects model is similar to an anove on a regular linear model: https://m-clark.github.io/docs/mixedModels/anovamixed.html)
anova(mod1)
anova(mod2)

anova(mod1, mod2) # Go with model 2 since pvalue >0.05, aka more complex model does not have something in it that matters (the two models are essentially the same so go w model with fewer parameters)
summary(mod1) 
summary(mod2)
AICctab(mod1, mod2, weights=T)

# Plot the fixed effects estimates for different models
# these are the fixed effects estimates from summary(mod1)
plot_model(mod2, sort.est = TRUE)
# these are the fixed predicted values:
plot_model(mod2, type = "pred", terms = c("year_factor", "state", "insecticide"))
# these are the random effects estimates
plot_model(mod2, type = "re", terms = c("species"))

# Do we need to include insecticide? (dropping insecticide from the model)
mod3 <- lmer(log(relabun) ~ state*year_factor + (1|species), comp_kbs_spp, REML=FALSE)
anova(mod2, mod3)

AICctab(mod2, mod3, weights=T)
# Looks like no pvalue > 0.05, so insecticide does not improve model fit so we will go with mod 3

# Does year need to be interactive with insecticide? - already removed insecticide
# mod4 <- lmer(log(julian_median) ~ state*year_factor + insecticide + (1|species) + (1|plot), umbs_flwr_spp, REML=FALSE)

# Does year need to be interactive with state?
mod5 <- lmer(log(relabun) ~ state + year_factor + (1|species), comp_kbs_spp, REML=FALSE)
anova(mod3, mod5)
# No, P>0.05 so state*year_factor doesn't strongly improve model fit so we will shift to mod5, but AIC values are super close!!

# Plot the fixed effects estimates for different models
# these are the fixed effects estimates from summary(mod5)
plot_model(mod5, sort.est = TRUE)
# these are the fixed predicted values:
plot_model(mod5, type = "pred", terms = c("year_factor", "state"))
# these are the random effects estimates
plot_model(mod5, type = "re", terms = c("species"))

# If we wanted to include plots nested within year it would look like this:
mod6 <- lmer(log(relabun) ~ state + year_factor + (1|species) + (1 + year_factor|plot), comp_kbs_spp, REML=FALSE)
anova(mod5, mod6)
anova(mod5)
```








Code below is a function written by Pat but unsuccessfully subsets sites so you get the same values for both kbs and umbs - above is a clumsy fix by Moriah (no function)
```{r, eval=FALSE}
#' function to calculate annual diversity index for a specific site
#'
#' after reading a comp file, this function should do all that's needed to prep it and
#' run the diversity function on for each year.  diversity indexes are for the year only,
#' the diversity indexes use total abundances for a year,  do not sum/count/pool abundances in other years
#'
#' @param comp plant composition data as read from project folder
#' @param site one of kbs or umbs as coded in the comp data
#' @param div_index is the same as 'index' for vegan::diversity function "shannon", "simpson" or "invsimpson".
#'
#' @returns a matrix (data frame) of diversity indices for one site with years in the columns, and plot in rows
#'
diversity_by_year <- function(comp, site, div_index = "shannon"){
    comp_site <- subset(comp, site == site) %>% dplyr::select(plot, species, cover, year)

    # remove non-species using "not in"
    #obs_to_exclude = c("Bare_Ground", "Unknown","Brown","Litter", "Vert_Litter", "Animal_Disturbance")
    #comp_site <-dplyr::filter(comp_site, !(species %in% obs_to_exclude))

    # convert the abundance data to abundance for each species in columns for the vegan package
    comp_wide <- matrify2(comp_site)

    # comp_wide_data is assumes to have columns Year, Plot, and columns for each species found, e.g. for Vegan

    # first, split up the wide data into a list of years.  Each list item is a year of data
    comp_wide_by_year <- dplyr::group_by(comp_wide, Year) %>% dplyr::group_split()

    # we need to add plot names.  Get those Plot names by taking a column from any one of the years
    # since we are assuming the Plot column is the exact same across years and IN THE SAME ORDER
    plot_names <- comp_wide_by_year[[1]]$Plot

    # remove the plot and year columns from each item in the list so that Vegan will work.
    # This assumes row order is the exact same for all years (each row a plot)
    comp_wide_by_year<- lapply(comp_wide_by_year, dplyr::select, c(-Year, -Plot))

    #  apply  the diversity function to each year  - in this case the main index is plot, each year considered separately
    diversity_by_year_list<- lapply(comp_wide_by_year,vegan::diversity, index = div_index)

    # each item in the list is a year of diversity, so name those with the years we know we have
    names(diversity_by_year_list) <- as.character(2015:2021)

    # "unlist" and create a new data frame, each year a column, each row a plot, and add a new row with the plot names
    x<- do.call(cbind,diversity_by_year_list) %>% cbind(Plot = plot_names ) %>% as.data.frame()
    #  an alternative tidyverse way x<- diversity_by_year(diversity_by_year_list)

    ## optional step!
    return(x)
}

comp$cover <- as.numeric(comp$cover)

# use the one function above to both matrify and calculate Shannon diversity index per year
diversity_by_year_kbs  <- diversity_by_year(comp, site = "kbs", div_index = "shannon")
diversity_by_year_umbs <- diversity_by_year(comp, site = "umbs", div_index = "shannon")

# this output has a column for each year 2015, 2016, and Plot, but if you need it narrow use 'melt' from reshape2: 
library(reshape2)
diversity_by_plot_year_kbs <- reshape2::melt(diversity_by_year_kbs, id =  "Plot", variable.name = c("Year"), value.name = "shannon") 
diversity_by_plot_year_umbs <- reshape2::melt(diversity_by_year_umbs, id =  "Plot", variable.name = c("Year"), value.name = "shannon") 

# To do just August (peak_comp):

peak_comp <- dplyr::filter(comp, month == 8)

peak_shannon_by_year_kbs  <- diversity_by_year(peak_comp, site = "kbs", div_index = "shannon")
peak_shannon_by_year_umbs  <- diversity_by_year(peak_comp, site = "umbs", div_index = "shannon")

peak_simpson_by_year_kbs <- diversity_by_year(peak_comp, site = "kbs", div_index = "simpson")
peak_simpson_by_year_umbs <- diversity_by_year(peak_comp, site = "umbs", div_index = "simpson")

# this output has a column for each year 2015, 2016, and Plot, but if you need it narrow use 'melt' from reshape2: 
peak_shannon_by_plot_year_kbs <- reshape2::melt(peak_shannon_by_year_kbs, id =  "Plot", variable.name = c("Year"), value.name = "shannon") 
peak_shannon_by_plot_year_umbs <- reshape2::melt(peak_shannon_by_year_umbs, id =  "Plot", variable.name = c("Year"), value.name = "shannon") 

# this output has a column for each year 2015, 2016, and Plot, but if you need it narrow use 'melt' from reshape2: 
peak_simpson_by_plot_year_kbs <- reshape2::melt(peak_simpson_by_year_kbs, id =  "Plot", variable.name = c("Year"), value.name = "simpson") 
peak_simpson_by_plot_year_umbs <- reshape2::melt(peak_simpson_by_year_umbs, id =  "Plot", variable.name = c("Year"), value.name = "simpson") 

diversity_kbs <- left_join(peak_shannon_by_plot_year_kbs, peak_simpson_by_plot_year_kbs)
diversity_kbs$site <- "kbs" #add site column

diversity_umbs <- left_join(peak_shannon_by_plot_year_umbs, peak_simpson_by_plot_year_umbs)
diversity_umbs$site <- "umbs" #add site column
```

Calculating Diversity Indices
```{r, eval=FALSE}
# species richness
sppr <- specnumber(comp1_wide)

sppr_aov <- aov(sppr ~ state, data = meta)
summary(sppr_aov)
```
